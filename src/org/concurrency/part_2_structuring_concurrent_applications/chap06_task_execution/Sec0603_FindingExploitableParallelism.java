package org.concurrency.part_2_structuring_concurrent_applications.chap06_task_execution;

import java.util.*;
import java.util.concurrent.*;

import static org.concurrency.part_1_fundamentals.chap05_building_blocks.Sec0505_Synchronizers.launderThrowable;

/**
 * Created by sofia on 5/28/17.
 */

/**
 * 6.3. Finding Exploitable Parallelism
 *
 * The Executor framework makes it easy to specify an execution policy,
 * but in order to use an Executor, you have to be able to describe your task as a Runnable.
 * There may be exploitable parallelism within a single client request in server applications,
 * as is sometimes the case in database servers.
 *
 * In this section we develop several versions of a component that admit varying degrees of concurrency.
 * Our sample component is the page-rendering portion of a browser application,
 * which takes a page of HTML and renders it into an image buffer.
 *
 * 6.3.1. Example: Sequential Page Renderer
 *
 * The simplest approach is to process the HTML document sequentially.
 * The approach involves rendering the text elements first, leaving rectangular placeholders for the images,
 * and after completing the initial pass on the document,
 * going back and downloading the images and drawing them into the associated placeholder.
 * This approach is shown in SingleThreadRenderer in Listing 6.10.
 *
 * Downloading an image mostly involves waiting for I/O to complete, and during this time the CPU does little work.
 * So the sequential approach may underutilize the CPU, and also makes the user wait longer than necessary to see the finished page.
 * We can achieve better utilization and responsiveness by breaking the problem into independent tasks that can execute concurrently.
 *
 * 6.3.2. Result-breaking Tasks: Callable and Future
 *
 * The Executor framework uses Runnable as its basic task representation.
 * Runnable is a fairly limiting abstraction.
 * Many tasks are effectively deferred computations.
 * For these types of tasks, Callable is a better abstraction:
 * it expects that the main entry point, call, will return a value and anticipates that it might throw an exception.
 *
 * The lifecycle of a task executed by an Executor has 4 phases: created, submitted, started, and completed.
 * Since tasks can take a long time to run, we also want to be able to cancel a task.
 * In the Executor framework, tasks that have been submitted but not yet started can always be cancelled,
 * and tasks that have started can sometimes be cancelled if they are responsive to interruption.
 * Cancelling a task that has already completed has no effect.
 *
 * Future represents the lifecycle of a task and provides methods to test whether the task has completed or been cancelled,
 * retrieve its result, and cancel the task.
 * Implicit in the specification of Future is that task lifecycle can only move forwards, not backwards - just like the ExecutorService lifecycle.
 * Once a task is completed, it stays in that state forever.
 *
 *      Listing 6.11. Callable and Future Interfaces.
 *
 *      public interface Callable<V> {
 *          V call() throws Exception;
 *      }
 *
 *      public interface Future<V> {
 *          boolean cancel(boolean mayInterruptIfRunning);
 *          boolean isCancelled();
 *          boolean isDone();
 *          V get() throws InterruptedException, ExecutionException, CancellationException;
 *          V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, CancellationException, TimeoutException;
 *      }
 *
 * The behavior of get varies depending on the task state (not yet started, running, completed).
 * It returns immediately or throws an Exception if the task has already completed,
 * but if not it blocks until the task completes.
 * If the task completes by throwing an exception, get rethrows it wrapped in an ExecutionException;
 * if it was cancelled, get throws CancellationException.
 * If get throws ExecutionException, the underlying exception can be retrieved with getCause.
 *
 * There are several ways to create a Future to describe a task.
 * The submit methods in ExecutorService all return a Future,
 * so that you can submit a Runnable or a Callable to an executor
 * and get back a Future that can be used to retrieve the result or cancel the task.
 * You can also explicitly instantiate a FutureTask for a given Runnable or Callable.
 *
 * As of Java 6, ExecutorService implementations can override newTaskFor in AbstractExecutorService
 * to control instantiation of the Future corresponding to a submitted Callable or Runnable.
 * The default implementation just creates a new FutureTask, as shown in Listing 6.12:
 *
 *      Listing 6.12. Default Implementation of newTaskFor in ThreadPoolExecutor.
 *
 *      protected <T> RunnableFuture<T> newTaskFor(Callable<T> task) {
 *          return new FutureTask<T>(task);
 *      }
 *
 * Submitting a Runnable or Callable to an Executor constitutes a safe publication of the Runnable or Callable
 * from the submitting thread to the thread that will eventually execute the task.
 * Similarly, setting the result value for a Future constitutes a safe publication of the result
 * from the thread in which it was computed to any thread that retrieves it via get.
 *
 * 6.3.3. Example: Page Renderer with Future
 *
 * As a first step towards making the page renderer more concurrent, let's divide it into 2 tasks,
 * one that renders the text and one that downloads all images.
 *
 * Callable and Future can help us express the interaction between these cooperating tasks.
 * In FutureRenderer in Listing 6.13, we create a Callable to download all the images, and submit it to an ExecutorService.
 * This returns a Future describing the task's execution;
 * when the main task gets to the point where it needs the images, it waits for the result by calling Future.get.
 *
 * The state-dependent nature of get means that the caller need not be aware of the state of the task,
 * and the safe publication properties of task submission and result retrieval make this approach thread-safe.
 * The exception handling code surrounding Future.get deals with two possible problems:
 * that the task encountered an Exception,
 * or the thread calling get was interrupted before the results were available.
 *
 * FutureRenderer allows the text to be rendered concurrently with downloading the image data.
 * But we can do considerably better.
 * There is no need for users to wait for all the images to be downloaded;
 * they would probably prefer to see individual images drawn as they become available.
 *
 * 6.3.4. Limitations of Parallelizing Heterogeneous Tasks
 *
 * FutureRendered uses 2 tasks: one for rendering text and one for downloading the images.
 * If rendering the text is much faster than downloading the images,
 * the resulting performance is not much different from the sequential version,
 * but the code is a lot more complicated.
 * And the best we can do with two threads is speed things up by a factor of two.
 * Thus, trying to increase concurrency by parallelizing heterogeneous activities can be a lot of work,
 * and there is a limit to how much additional concurrency you can get out of it.
 *
 * The real performance payoff of dividing a program's workload into tasks comes
 * when there are a large number of independent, homogeneous tasks that can be processed concurrently.
 *
 * 6.3.5. CompletionService: Executor Meets BlockingQueue
 *
 * If you have a batch of computations to submit to an Executor and you want to retrieve their results as they become available,
 * you could retain the Future associated with each task and repeatedly poll for completion by calling get with a timeout of zero.
 * Fortunately, there is a better way: a completion service.
 *
 * CompletionService combines the functionality of an Executor and a BlockingQueue.
 * You can submit Callable tasks to it for execution and use the queue-like methods take and poll to retrieve completed results,
 * packaged as Futures, as they become available.
 *
 * ExecutorCompletionService implements CompletionService, delegating the computation to an Executor.
 * The implementation of ExecutorCompletionService is quite straightforward.
 * The constructor creates a BlockingQueue to hold the completed results.
 * When a task is submitted, it is wrapped with a QueueingFuture,
 * a subclass of FutureTask that overrides done to place the result on the BlockingQueue, as shown in Listing 6.14.
 * The take and poll methods delegate to the BlockingQueue, blocking if results are not yet available.
 *
 *      Listing 6.14. QueueingFuture Class Used by ExecutorCompletionService.
 *
 *      private class QueueingFuture<V> extends FutureTask<V> {
 *          QueueingFuture(Callable<V> c) { super(c); }
 *          QueueingFuture(Runnable t, V r) { super(t, r); }
 *
 *          protected void done() {
 *              completionQueue.add(this);
 *          }
 *      }
 *
 * 6.3.6. Example: Page Renderer with CompletionService
 *
 * We can use a CompletionService to improve the performance of the page renderer in 2 ways:
 * shorter total runtime and improved responsiveness.
 *
 * We can create a separate task for downloading each image and execute them in a thread pool,
 * turning the sequential download into a parallel one:
 * this reduces the amount of time to download all the images.
 * And by fetching the results from the CompletionService and rendering each image as soon as it is available,
 * we can give the user a more dynamic and responsive user interface.
 *
 * This implementation is shown in Renderer in Listing 6.15.
 *
 * Multiple ExecutorCompletionServices can share a single Executor,
 * so it is perfectly sensible to create an ExecutorCompletionService that is private to a particular computation
 * while sharing a common Executor.
 * When used in this way, a CompletionService acts as a handle for a batch of computations
 * in much the same way that a Future acts as a handle for a single computation.
 * By remembering how many tasks were submitted to the CompletionService and counting how many completed results are retrieved,
 * you can know when all the results for a given batch have been retrieved, even if you use a shared Executor.
 *
 * 6.3.7. Placing Time Limits on Tasks
 *
 * Sometimes, if an activity does not complete within a certain amount of time,
 * the result is no longer needed and the activity can be abandoned.
 *
 * The primary challenge in executing tasks within a time budget is making sure that you don't wait longer than the time budget
 * to get an answer or find out that one is not forthcoming.
 * The timed version of Future.get supports this requirement:
 * it returns as soon as the result is ready, but throws TimeoutException if the result is not ready within the timeout period.
 *
 * A secondary problem when using timed tasks is to stop them when they run out of time,
 * so they do not waste computing resources by continuing to compute a result that will not be used.
 * This can be accomplished by having the task strictly manage its own time budget and abort if it runs out of time,
 * or by cancelling the task if the timeout expires.
 * Again, Future can help;
 * if a timed get completes with a TimeoutException, you can cancel the task through the Future.
 * If the task is written to be cancellable, it can be terminated early so as not to consume excessive resources.
 * This technique is used in Listings 6.13 and 6.16.
 *
 * Listing 6.16 shows a typical application of a timed Future.get.
 * It generates a composite web page that contains the requested content plus an advertisement fetched from an ad server.
 * It submits the ad-fetching task to an executor, computes the rest of the page content, and then waits for the ad until its time budget runs out.
 * If the get times out, it cancels the ad-fetching task and uses a default advertisement instead.
 *
 * 6.3.8. Example: A Travel Reservation Portal
 *
 * The time-budgeting approach can be easily generalized to an arbitrary number of tasks.
 *
 * Listing 6.17 uses the timed version of invokeAll to submit multiple tasks to an ExecutorService and retrieve the results.
 * The invokeAll method takes a collection of tasks and returns a collection of Futures.
 * The two collections have identical structures;
 * invokeAll adds the Futures to the returned collection in the order imposed by the task collection's iterator,
 * thus allowing the caller to associate a Future with the Callable it represents.
 * The timed version of invokeAll will return when all the tasks have completed, the calling thread is interrupted, or the timeout expires.
 * Any tasks that are not complete when the timeout expires are cancelled.
 * On return from invokeAll, each task will have either completed normally or been cancelled;
 * the client code can call get or isCancelled to find out which.
 */
public class Sec0603_FindingExploitableParallelism {

    /**
     * 6.3.1. Example: Sequential Page Renderer
     */

    /**
     * Listing 6.10. Rendering Page Elements Sequentially.
     */
    public static class SingleThreadRenderer {

        void renderPage(CharSequence source) {
            renderText(source);
            List<ImageData> imageData = new ArrayList<>();

            for (ImageInfo imageInfo : scanForImageInfo(source))
                imageData.add(imageInfo.downloadImage());

            for (ImageData data : imageData)
                renderImage(data);
        }

        private void renderText(CharSequence source) {}

        private List<ImageInfo> scanForImageInfo(CharSequence source) {
            return null;
        }

        private void renderImage(ImageData data) {}
    }

    static class ImageData {}

    static class ImageInfo {
        ImageData downloadImage() { return null; }
    }

    /**
     * 6.3.3. Example: Page Renderer with Future
     */

    /**
     * Listing 6.13. Waiting for Image Download with Future.
     */
    public static class FutureRenderer {
        private final ExecutorService executor = Executors.newFixedThreadPool(100);

        void renderPage(CharSequence source) {
            final List<ImageInfo> imageInfos = scanForImageInfo(source);

            Callable<List<ImageData>> task = new Callable<List<ImageData>>() {
                public List<ImageData> call() {
                    List<ImageData> result = new ArrayList<>();

                    for (ImageInfo imageInfo : imageInfos)
                        result.add(imageInfo.downloadImage());

                    return result;
                }
            };

            Future<List<ImageData>> future = executor.submit(task);

            renderText(source);

            try {
                List<ImageData> imageData = future.get();
                for (ImageData data : imageData)
                    renderImage(data);
            } catch (InterruptedException e) {
                // Re-assert the thread's interrupted status
                Thread.currentThread().interrupt();
                // We don't need the result, so cancel the task too
                future.cancel(true);
            } catch (ExecutionException e) {
                throw launderThrowable(e.getCause());
            }
        }

        private void renderText(CharSequence source) {}

        private List<ImageInfo> scanForImageInfo(CharSequence source) {
            return null;
        }

        private void renderImage(ImageData data) {}
    }

    /**
     * 6.3.6. Example: Page Renderer with CompletionService
     */

    /**
     * Listing 6.15. Using CompletionService to Render Page Elements as they Become Available.
     */
    public static class Renderer {

        private final ExecutorService executor;

        Renderer(ExecutorService executor) {
            this.executor = executor;
        }

        void renderPage(CharSequence source) {
            final List<ImageInfo> info = scanForImageInfo(source);

            CompletionService<ImageData> completionService = new ExecutorCompletionService<>(executor);

            for (final ImageInfo imageInfo : info) {
                completionService.submit(new Callable<ImageData>() {
                    public ImageData call() {
                        return imageInfo.downloadImage();
                    }
                });
            }

            renderText(source);

            try {
                for (int t = 0, n = info.size(); t < n; t++) {
                    Future<ImageData> f = completionService.take();
                    ImageData imageData = f.get();
                    renderImage(imageData);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } catch (ExecutionException e) {
                throw launderThrowable(e.getCause());
            }
        }

        private void renderText(CharSequence source) {}

        private List<ImageInfo> scanForImageInfo(CharSequence source) {
            return null;
        }

        private void renderImage(ImageData data) {}
    }

    /**
     * 6.3.7. Placing Time Limits on Tasks
     */
    /**
     * Listing 6.16. Fetching an Advertisement with a Time Budget.
     */
    static Page renderPageWithAd() throws InterruptedException {
        long endNanos = System.nanoTime() + TIME_BUDGET;
        Future<Ad> f = exec.submit(new FetchAdTask());
        // Render the page while waiting for the ad
        Page page = renderPageBody();
        Ad ad;

        try {
            // Only wait for the remaining time budget
            long timeLeft = endNanos - System.nanoTime();
            ad = f.get(timeLeft, NANOSECONDS);
        } catch (ExecutionException e) {
            ad = DEFAULT_AD;
        } catch (TimeoutException e) {
            ad = DEFAULT_AD;
            f.cancel(true);
        }

        page.setAd(ad);

        return page;
    }

    static class Page {
        void setAd(Ad ad) {};
    }

    static class Ad {}

    static class FetchAdTask implements Callable {
        public Object call() {
            return null;
        }
    }

    static Page renderPageBody() { return null; }

    private static final long TIME_BUDGET = 10;
    private static final TimeUnit NANOSECONDS = TimeUnit.NANOSECONDS;

    private static final Ad DEFAULT_AD = null;

    private static ExecutorService exec = Executors.newFixedThreadPool(100);

    /**
     * 6.3.8. Example: A Travel Reservation Portal
     */

    /**
     * Listing 6.17. Requesting Travel Quotes Under a Time Budget.
     */
    public static List<TravelQuote> getRankedTravelQuotes(TravelInfo travelInfo, Set<TravelCompany> companies,
                                                          Comparator<TravelQuote> ranking, long time, TimeUnit unit)
        throws InterruptedException {

        List<QuoteTask> tasks = new ArrayList<>();

        for (TravelCompany company : companies)
            tasks.add(new QuoteTask(company, travelInfo));

        List<Future<TravelQuote>> futures = exec.invokeAll(tasks, time, unit);
        List<TravelQuote> quotes = new ArrayList<>(tasks.size());
        Iterator<QuoteTask> taskIter = tasks.iterator();

        for (Future<TravelQuote> f : futures) {
            QuoteTask task = taskIter.next();

            try {
                quotes.add(f.get());
            } catch (ExecutionException e) {
                quotes.add(task.getFailureQuote(e.getCause()));
            } catch (CancellationException e) {
                quotes.add(task.getTimeoutQuote(e));
            }
        }

        Collections.sort(quotes, ranking);

        return quotes;
    }

    private static class QuoteTask implements Callable<TravelQuote> {
        private final TravelCompany company;
        private final TravelInfo travelInfo;

        public QuoteTask(TravelCompany company, TravelInfo travelInfo) {
            this.company = company;
            this.travelInfo = travelInfo;
        }

        public TravelQuote call() throws Exception {
            return company.solicitQuote(travelInfo);
        }

        public TravelQuote getFailureQuote(Throwable t) { return null; }

        public TravelQuote getTimeoutQuote(CancellationException e) { return null; }
    }

    private static class TravelQuote {}

    private static class TravelCompany {
        TravelQuote solicitQuote(TravelInfo travelInfo) { return null; }
    }

    private static class TravelInfo {}



    public static void main(String[] args) throws Exception {
        SingleThreadRenderer singleThreadRenderer = new SingleThreadRenderer();
        FutureRenderer futureRenderer = new FutureRenderer();
        Renderer renderer = new Renderer(null);

        renderPageWithAd();
        getRankedTravelQuotes(null, null, null, 0, null);
    }

}
